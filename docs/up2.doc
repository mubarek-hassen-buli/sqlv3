üö® Context (Very Important)

The current implementation visualizes SQL syntax (keywords like SELECT, WHERE, JOIN).

This is architecturally wrong.

We are NOT building:

a SQL formatter

a clause flowchart

a keyword diagram

We ARE building:

A SQL logical execution & data-flow visualizer (SQLFlow-style)

The goal is to explain how data moves and transforms, not how SQL is written.

üß† Core Mental Model (Do Not Violate This)

SQL is not text.
SQL is a sequence of relational transformations.

The app must visualize:

relations (tables / intermediate results)

operators (join, filter, aggregate)

column lineage

schema evolution

If something does not contribute to explaining data flow, it should not exist.

‚ùå What to REMOVE / STOP DOING
1. Stop using SQL keywords as diagram nodes

‚ùå DELETE nodes like:

SELECT

WHERE

GROUP BY

INSERT

UPDATE

These are syntax, not execution.

2. Stop drawing linear ‚ÄúSCAN ‚Üí SELECT‚Äù pipelines

This is misleading and teaches nothing.

Execution is a DAG, not a sentence.

3. Stop thinking in ‚Äústeps of SQL text‚Äù

Do NOT map:

FROM ‚Üí WHERE ‚Üí GROUP BY ‚Üí SELECT


Instead, map:

Relation ‚Üí Operator ‚Üí Relation ‚Üí Operator ‚Üí Relation

‚úÖ What to BUILD INSTEAD (Mandatory)
1Ô∏è‚É£ Introduce Relation Nodes (First-Class Citizens)

A Relation represents a table-like structure.

Examples:

Base tables (customers, orders)

Intermediate results

Final query result

Relation Node MUST contain:
{
  id: string;
  type: "Relation";
  name: string;           // e.g. "customers", "RESULT_1"
  columns: {
    name: string;
    dataType?: string;
    source?: string;      // lineage
  }[];
}


Relations are the main visible boxes in the UI.

2Ô∏è‚É£ Introduce Operator Nodes (Transformers)

Operators transform one or more relations into a new relation.

Examples:

Scan

Filter

Join

Project

Aggregate

Sort

Insert

Operator Node:
{
  id: string;
  type: "Operator";
  operator:
    | "Scan"
    | "Filter"
    | "Join"
    | "Project"
    | "Aggregate"
    | "Sort"
    | "Insert";
  details: object; // conditions, join keys, expressions
}


Operators should be smaller nodes visually than relations.

3Ô∏è‚É£ Every Operator MUST Produce a New Relation

This is non-negotiable.

‚ùå Wrong:

customers ‚Üí SELECT


‚úÖ Correct:

customers ‚Üí Project ‚Üí RESULT_1


No operator exists without an output relation.

4Ô∏è‚É£ Implement Schema Propagation

Each operator must compute its output schema.

Examples:

Filter

Input columns = output columns (unchanged)

Project

Output columns = selected expressions

Join

Output columns = left columns + right columns

Aggregate

Output columns = group keys + aggregates

Without schema propagation:

no explanation

no lineage

no serious product

5Ô∏è‚É£ Track Column Lineage

Each column in every relation should know:

where it came from

how it was transformed

Example:

{
  name: "total_sal",
  source: "SUM(emp.sal)"
}


This enables:

hover explanations

lineage highlighting

SQLFlow-style insights

üß© Required Internal Model (Do This First)

Build an internal logical plan graph, BEFORE rendering.

Logical Plan = DAG
{
  nodes: (RelationNode | OperatorNode)[];
  edges: {
    from: string;
    to: string;
    type: "data-flow";
  }[];
}


Rendering comes after this model is correct.

üîÅ How to Convert SQL ‚Üí Logical Plan (High Level)

Parse SQL into AST

Convert AST into relational operators

Build operator tree (logical plan)

Insert intermediate relation nodes

Propagate schemas

Generate graph JSON

Layout (ELK / Dagre)

Render

üñº UI Rendering Rules (Important)
Visual hierarchy:

üü© Relations ‚Üí big boxes with columns

‚¨ú Operators ‚Üí small boxes

‚û°Ô∏è Edges ‚Üí data flow

Color coding:

Base tables ‚Üí green

Intermediate results ‚Üí gray

Final result ‚Üí red

This is not aesthetic ‚Äî it is cognitive clarity.

üß™ Example (This Is the Target)
SQL
SELECT id, city
FROM customers
WHERE city = 'London';

Correct Visualization
customers
(id, name, city)
      ‚îÇ
      ‚ñº
Filter (city = 'London')
      ‚îÇ
      ‚ñº
RESULT_1
(id, name, city)
      ‚îÇ
      ‚ñº
Project (id, city)
      ‚îÇ
      ‚ñº
RESULT_2
(id, city)


If the diagram does not look like this conceptually, it is wrong.

üö´ What Not to Optimize Prematurely

Performance cost

Index usage

Query execution time

This tool is logical, not physical.

üß† Product Bar (Non-Negotiable)

Before shipping a feature, ask:

‚ÄúDoes this help a human understand how data flows and changes?‚Äù

If the answer is no ‚Äî do not implement it.

‚úÖ Final Instruction Summary

Rewrite diagram logic around relations

Treat operators as transformers, not endpoints

Track schemas and lineage

Generate intermediate results

Render execution, not syntax