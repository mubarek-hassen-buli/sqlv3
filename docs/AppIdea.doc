üß† SQL Visualizer ‚Äî Detailed Explanation
What This App Really Is

SQL Visualizer is a SQL semantic analysis engine with a visual frontend.

It does not:

Execute SQL

Connect to databases

Estimate real costs

Read schemas

It does:

Parse SQL into an AST

Understand SQL semantics (execution stages & data flow)

Build a Directed Acyclic Graph (DAG) of execution operators

Precompute diagram layout (node positions + edge routing)

Render an interactive diagram in the browser

This is the same architectural class as SQLFlow.

The Core Principle (Non-Negotiable)

SQL is not visualized as text.
SQL is visualized as execution stages and data flow.

That is the single most important idea in the entire app.

End-to-End Flow
User SQL
   ‚Üì
SQL Parser (AST)
   ‚Üì
Semantic Analyzer
   ‚Üì
Execution DAG (nodes + edges)
   ‚Üì
Layout Engine (ELK.js)
   ‚Üì
Diagram JSON (with positions)
   ‚Üì
Frontend Canvas Renderer


The frontend never decides layout or meaning.
It only draws what the backend tells it.

1. SQL Parsing Layer
Responsibility

Convert raw SQL text into a machine-readable structure.

Input
SELECT u.id, COUNT(o.id)
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;

Output

An Abstract Syntax Tree (AST) representing the SQL.

This AST is syntax only, not meaning.

No diagrams here.

2. Semantic Analysis Layer (The Heart)

This is where your app becomes SQLFlow-level.

Responsibility

Convert syntax into execution meaning.

The analyzer answers questions like:

What tables are scanned?

Which table drives the query?

Is this an INNER or LEFT data flow?

Where does aggregation happen?

Is a filter applied before or after a join?

Where does a subquery begin/end?

Example Semantic Interpretation

The SQL:

FROM users u
LEFT JOIN orders o ON u.id = o.user_id


Becomes:

users ‚Üí driving table

orders ‚Üí optional input

Join operator ‚Üí LEFT JOIN data flow

This produces execution stages, not SQL clauses.

3. Execution DAG (Internal Graph Model)

The semantic analyzer builds a Directed Acyclic Graph (DAG).

Nodes Represent Execution Operators

Examples:

TABLE_SCAN(users)

TABLE_SCAN(orders)

JOIN(LEFT, u.id = o.user_id)

AGGREGATE(GROUP BY u.id, COUNT)

OUTPUT

Edges Represent Data Flow

Edges mean:

‚ÄúData produced by node A flows into node B‚Äù

Not ‚Äúline order in SQL‚Äù.

4. Graph Modeling Layer

At this stage:

You have pure graph data

No layout

No visuals

No UI concepts

Just:

Nodes

Edges

Metadata

This graph is reusable for:

Execution view

Join graph

Lineage view

Future features

5. Layout Engine (Why SQLFlow Looks Professional)

This is the visual secret sauce.

What Happens Here

The execution DAG is sent to a layout engine

The layout engine computes:

Node x/y positions

Edge routing paths

Layered top-to-bottom structure

Tool

ELK.js (layered layout)

Output

A graph where every node and edge has absolute coordinates.

From this point on:

Layout is frozen

Frontend does not rearrange anything

This is exactly how SQLFlow works.

6. Diagram JSON (Backend Output)

The backend returns a single JSON payload containing:

Nodes (id, type, label, x, y, metadata)

Edges (from, to, routing points)

Optional warnings or annotations

This JSON is the source of truth.

7. Frontend Rendering Layer
Responsibility

Render the diagram exactly as specified.

Characteristics

No layout logic

No SQL understanding

No graph decisions

It only:

Draws shapes

Draws arrows

Handles interaction (zoom, pan, click)

Rendering Style

Canvas-based (Excalidraw-like)

Interactive

Developer-tool UX

8. Interactions (Like SQLFlow)

Click node ‚Üí inspect details

Hover edge ‚Üí highlight data flow

Zoom out ‚Üí see high-level stages

Zoom in ‚Üí see detailed operators

All powered by the same DAG.