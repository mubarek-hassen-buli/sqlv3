Executive Summary (read this first)

Your current app fails because:

You visualize SQL syntax

Real tools visualize data transformations

You don’t model relations, schemas, or intermediate results

You don’t separate parsing, planning, and explanation

To build a real product, you must:

Stop thinking in SQL clauses

Build a Logical Query Planner

Model Relational Algebra, not text

Track schemas + lineage at every step

Treat intermediate results as first-class objects

Explain why each operator exists, not just that it exists

This is not optional. This is the minimum bar.

1. Fundamental Conceptual Shift (Non-Negotiable)
❌ Your current mental model

“SQL is a sequence of clauses that I can draw”

✅ Required mental model

“SQL describes a graph of data transformations over relations”

SQL is not the execution plan.
It is a declarative language that gets compiled into a relational algebra plan.

Your product lives after parsing, before execution.

2. What EXACTLY Is Wrong in Your Current App

I’ll be precise.

2.1 You visualize syntax, not semantics

Your nodes:

SELECT
WHERE
GROUP BY
JOIN


These answer:

“What keywords are in the query?”

They do NOT answer:

What data flows

What rows are filtered

What columns are produced

What aggregation happens

Why joins exist

➡️ This is why your explanation feels empty.

2.2 You do not model relations

In SQLFlow:

Tables

Subqueries

Join outputs

Aggregate outputs

are relations.

In your app:

There is no concept of a relation

Everything is just a step in a chain

This kills comprehension.

2.3 You do not track schema or lineage

SQLFlow can answer:

Where did sal_sum come from?

Why does this result have 5 columns?

Which table produced this column?

Your app cannot answer any of these.

That makes it unusable for real users.

2.4 You do not name intermediate results

Humans reason in chunks.

SQLFlow creates:

RESULT_OF_A-1
INSERT-SELECT-1
RS-1


You produce anonymous joins.

Anonymous data is impossible to explain.

3. What You Must Build Instead (High-Level Architecture)

You need four distinct layers. No shortcuts.

┌──────────────┐
│ SQL Parser   │
└──────┬───────┘
       ↓
┌──────────────┐
│ Logical Plan │  ← CORE OF YOUR PRODUCT
└──────┬───────┘
       ↓
┌──────────────┐
│ Lineage &    │
│ Schema Flow  │
└──────┬───────┘
       ↓
┌──────────────┐
│ Explanation  │
│ & Visualization │
└──────────────┘


Your app currently jumps from Parser → Visualization, which is why it fails.

4. The Core: Logical Query Plan (This Is Everything)
4.1 What a Logical Plan Is

A Logical Plan is a tree (or DAG) of relational operators.

Each operator:

Takes relations as input

Produces a new relation as output

This is how databases think.

4.2 Operator Types You MUST Support

These are not optional if this is a real product.

Source Operators

TableScan

SubqueryScan

Values (constants)

Transformation Operators

Filter

Project

Join

Aggregate

Sort

Limit

Sink Operators

Insert

Update

Delete

Result

If an operation does not fit here, it’s wrong.

4.3 Example (Real Transformation)

SQL:

SELECT deptno, COUNT(*), SUM(sal)
FROM emp
WHERE sal > 1000
GROUP BY deptno;


Logical Plan:

Aggregate(deptno, COUNT(*), SUM(sal))
  ← Filter(sal > 1000)
    ← TableScan(emp)


Notice:

No SELECT

No WHERE

No GROUP BY

Those are syntax, not operations.

5. Schema & Lineage (This Is Why SQLFlow Feels Smart)
5.1 Every Node Must Have a Schema

Each plan node must define:

interface Schema {
  columns: Column[];
}

interface Column {
  name: string;
  type: string;
  source?: {
    table?: string;
    column?: string;
    expression?: string;
  };
}


Without this, explanation is impossible.

5.2 Schema Propagation Rules (Critical)
TableScan

Schema = table columns

Filter

Schema = input schema (unchanged)

Project

Schema = projected expressions

Example:

SELECT sal * 12 AS annual_salary


Column source:

expression: "sal * 12"

Join

Schema = left.columns + right.columns

With lineage preserved:

emp.sal
dept.deptno

Aggregate

Schema = group keys + aggregate outputs

This is where most visualizers fail.
Do NOT fail here.

6. Intermediate Results (Why SQLFlow Is Readable)

Every operator produces a named relation.

Examples:

JOIN_RESULT_1

AGG_RESULT_2

FILTERED_EMP

These names:

Are auto-generated

Must be stable

Must be referenced downstream

This is what enables:

Explanation

Highlighting

Hover-to-understand UX

7. Explanation Layer (This Is Your Product Value)

Once you have a logical plan + schema, explanations become deterministic.

7.1 Example Explanation

For a Filter node:

“This step removes rows from emp where sal <= 1000.
Input rows: N
Output rows: M”

For an Aggregate node:

“Rows are grouped by deptno.
For each group:

COUNT(*) is calculated

SUM(sal) is calculated”

This is impossible in your current design.

7.2 Explanation Is Data-Driven, Not Hand-Written

Never hardcode explanations per SQL keyword.

Each operator has:

Inputs

Outputs

Expressions

Explanation = rendering those facts in natural language.

8. Visualization Rules (Why SQLFlow Looks “Right”)
8.1 Visual Grammar (Important)

Relations → Rectangles

Operators → Distinct shapes/colors

Columns → Listed inside relations

Constants → Separate nodes

This is not aesthetic — it’s cognitive science.

8.2 Direction Matters

SQLFlow flows:

Sources → Transformations → Results


Your app currently mixes logical order and textual order.

Only dataflow direction is acceptable.

9. Libraries You Should Use (Reality Check)
9.1 Parsing

pgsql-ast-parser (JS)

Or ANTLR if you want full control

Parsing is not your product.

9.2 Planning

There is no library that does this for you.

Why?
Because this is the same layer:

PostgreSQL planner

Apache Calcite

DuckDB planner

You must build a simplified logical planner.

That’s normal for serious products.

10. How to Migrate From Your Current App (Concrete Steps)
Step 1: Delete clause-based nodes

Remove:

SELECT
WHERE
GROUP BY

Step 2: Introduce operator nodes

Add:

Scan
Filter
Join
Aggregate
Project
Result

Step 3: Build Logical Plan from AST

AST → Logical Plan (recursive)

Step 4: Add schema propagation

Each node computes its output schema

Step 5: Add intermediate result naming

Every node produces a relation ID

Step 6: Rewrite visualization to use relations

Visualize relations + operators, not keywords

11. Hard Truth (But You Asked For It)

You are no longer building:

“A SQL visualizer”

You are building:

A SQL logical planner + explainer

This is why:

It feels hard

Existing tools feel “magical”

There are no npm packages

You are now competing with database internals, just at the logical level.

That’s not bad.